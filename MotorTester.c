#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Hubs, S2, HTMotor, HTMotor, none, none)
#pragma config(Sensor, S1, , sensorI2CMuxController)
#pragma config(Sensor, S2, , sensorI2CMuxController)
#pragma config(Sensor, S3, IR, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, BackSideways, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C1_2, RightForward, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C2_1, LeftForward, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_2, FrontSideways, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S2_C1_1, ShoulderLeft, tmotorTetrix, openLoop, encoder)
#pragma config(Motor, mtr_S2_C1_2, ShoulderRight, tmotorTetrix, openLoop, reversed)
#pragma config(Motor, mtr_S2_C2_1, ArmLeft, tmotorTetrix, openLoop, encoder)
#pragma config(Motor, mtr_S2_C2_2, ArmRight, tmotorTetrix, openLoop, reversed)
#pragma config(Motor, motorA, ArmHandLeft, tmotorNXT, PIDControl, encoder)
#pragma config(Motor, motorB, ArmHandRight, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#include "constants.h"

bool motorLeftForward = false; //Says whether we are testing an encoder or not
bool motorRightForward = false;
bool motorBackSideways = false;
bool motorFrontSideways = false;

task main() {
	//Initialize
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = motor[ArmLeft] = motor[ArmRight] = motor[ShoulderLeft] = motor[ShoulderRight] = motor[ArmHandLeft] = motor[ArmHandRight] = 0; //Turn off the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = nMotorEncoder[ArmLeft] = nMotorEncoder[ShoulderLeft] = nMotorEncoder[ArmHandLeft] = 0; //Might as well reset the encoders too

	waitForStart();

	while(true) {
		//Drive
		if(joy1Btn(1)) //If button 1 is pressed, start the motor
			motor[LeftForward] = 100;
		else if(!motorLeftForward) //If we aren't testing the encoder, stop the motor
			motor[LeftForward] = 0;
		if(joy1Btn(2))
			motor[RightForward] = 100;
		else if(!motorRightForward)
			motor[RightForward] = 0;
		if(joy1Btn(3))
			motor[BackSideways] = 100;
		else if(!motorBackSideways)
			motor[BackSideways] = 0;
		if(joy1Btn(4))
			motor[FrontSideways] = 100;
		else if(!motorFrontSideways)
			motor[FrontSideways] = 0;

		if(joystick.joy1_TopHat == 0) { //Start testing encoder if top D-Pad button is pressed
			nMotorEncoder[LeftForward] = 0; //Reset the encoder
			motor[LeftForward] = 100; //Go!
			motorLeftForward = true; //Now testing LeftForward
		}
		if(joystick.joy1_TopHat == 2) { //Right D-Pad button
			nMotorEncoder[RightForward] = 0;
			motor[RightForward] = 100;
			motorRightForward = true;
		}
		if(joystick.joy1_TopHat == 4) { //Bottom D-Pad button
			nMotorEncoder[BackSideways] = 0;
			motor[BackSideways] = 100;
			motorBackSideways = true;
		}
		if(joystick.joy1_TopHat == 6) { //Left D-Pad button
			nMotorEncoder[FrontSideways] = 0;
			motor[FrontSideways] = 100;
			motorFrontSideways = true;
		}
		if(motorLeftForward && nMotorEncoder[LeftForward] >= ENCODERTEST) { //If we are testing encoder and time to stop, stop the motor
			motor[LeftForward] = 0;
			motorLeftForward = false;
		}
		if(motorRightForward && nMotorEncoder[RightForward] >= ENCODERTEST) {
			motor[RightForward] = 0;
			motorRightForward = false;
		}
		if(motorBackSideways && nMotorEncoder[BackSideways] >= ENCODERTEST) {
			motor[BackSideways] = 0;
			motorBackSideways = false;
		}
		if(motorFrontSideways && nMotorEncoder[FrontSideways] >= ENCODERTEST) {
			motor[FrontSideways] = 0;
			motorFrontSideways = false;
		}

		//Arm

		if(joy1Btn(5)) { //If button 5 is pressed, start arm up
			if(nMotorEncoder[ArmRight] < ARMTOP) //Protects from operator forcing the arm above its highest point
				motor[ArmLeft] = motor[ArmRight] = ARMHIGH;
			else
				motor[ArmLeft] = motor[ArmRight] = 0;
		}
		if(joy1Btn(7)) { //If button 7 is pressed, start arm down
			if(nMotorEncoder[ArmLeft] > ARMBOTTOM) //Protects from operator forcing the arm below its lowest point
				motor[ArmLeft] = motor[ArmRight] = -ARMDOWNHIGH;
			else
				motor[ArmLeft] = motor[ArmRight] = 0;
		}

		//Shoulder

		if(joy1Btn(6)) { //If button 6 pressed, start shoulder up
			if(nMotorEncoder[ArmLeft] < SHOULDERTOP) //Protects from operator forcing the arm above its highest point
				motor[ArmLeft] = motor[ArmRight] = SHOULDERHIGH;
			else
				motor[ArmLeft] = motor[ArmRight] = 0;
		}
		if(joy1Btn(8)) { //If button 8 is pressed, start shoulder down
			if(nMotorEncoder[ShoulderLeft] > SHOULDERBOTTOM) //Protects from operator forcing the arm below its lowest point
				motor[ShoulderLeft] = motor[ShoulderRight] = -SHOULDERDOWNHIGH;
			else
				motor[ShoulderLeft] = motor[ShoulderRight] = 0;
		}

		//Hand

		if(joy1Btn(9)) { //If button 9 pressed, open hand
			if(nMotorEncoder[ArmHandLeft] < HANDMAX) //Protects from operator forcing the hand past its open point
				motor[ArmHandLeft] = motor[ArmHandRight] = ARMHIGH;
			else
				motor[ArmHandLeft] = motor[ArmHandRight] = 0;
		}
		if(joy1Btn(10)) { //If button 10 is pressed, close hand
			if(nMotorEncoder[ArmLeft] > HANDMIN) //Protects from operator forcing the hand past its closed point
				motor[ArmHandLeft] = motor[ArmHandRight] = -ARMHIGH;
			else
				motor[ArmHandLeft] = motor[ArmHandRight] = 0;
		}
	}
}
