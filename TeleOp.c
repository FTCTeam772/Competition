#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Hubs, S2, HTMotor, HTServo, none, none)
#pragma config(Sensor, S3, IR, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, LeftForward, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C1_2, FrontSideways, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_1, BackSideways, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C2_2, RightForward, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_1, ArmLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_2, ArmRight, tmotorTetrix, PIDControl, encoder)
#pragma config(Servo, srvo_S2_C2_1, ArmServoLeft, tServoStandard)
#pragma config(Servo, srvo_S2_C2_2, ArmServoRight, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#define JOYSTICKHIGH 100
#define JOYSTICKLOW 30
#define ARMHIGH 100
#define ARMLOW 30
#define SERVOHIGH 10
#define SERVOLOW 2

//Initialize our globals
byte joystickFactor = JOYSTICKHIGH; //Used to scale down robot movements
byte armFactor = ARMHIGH; //Used to scale arm movements
byte servoFactor = SERVOHIGH;
bool forward = true; //Used for direction locking
bool sideways = true;

task joystickControl() { //Asynchronous task for joystick control
	while(true) {
		//Jostick 1 - Driver
		if(forward) { //Part of direction locking mechanism
			//Big fancy statement to set the left forward motors equal to the converted joystick's left y axis unless it is in the natural variant range.
			motor[LeftForward] = joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 / 128.0 * joystickFactor : 0;
			//Same for right and for sideways (but use the second y axis for right side and use the x axes for sideways motors)
			motor[RightForward] = joystick.joy1_y2 > 10 || joystick.joy1_y2 < -10 ? joystick.joy1_y2 / 128.0 * joystickFactor : 0;
		}
  	if(sideways) {
			motor[BackSideways] = joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 / 128.0 * joystickFactor : 0;
			motor[FrontSideways] = joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 / 128.0 * joystickFactor : 0;
		}
		//Joystick 2 - Operator
		if(joy2Btn(7))
			servoFactor = SERVOLOW;
		else
			servoFactor = SERVOHIGH;
		if(joy2Btn(8))
			armFactor = ARMLOW;
		else
			armFactor = ARMHIGH;
		if(joy2Btn(5)) {
			servo[ArmServoLeft] += servoFactor;
			servo[ArmServoRight] += servoFactor;
		}
		if(joy2Btn(6)) {
			servo[ArmServoLeft] -= servoFactor;
			servo[ArmServoRight] -= servoFactor;
		}
		switch(joystick.joy2_TopHat) {
			case 7: //If tophat is one of the top three states, move arm up
			case 0:
			case 1:
				motor[ArmLeft] = motor[ArmRight] = armFactor;
				break;
			case 3: //If tophat is one of the bottom three states, move arm down
			case 4:
			case 5:
				motor[ArmLeft] = motor[ArmRight] = -armFactor;
			default: //Else stop it
				motor[ArmLeft] = motor[ArmRight] = 0;
		}
	}
}

task main() {
	//Initialize
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = 0; //Turn off the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = 0; //Might as well reset the encoders too
	waitForStart();
	StartTask(joystickControl); //Go ahead and start joysticks in their own task
	while(true) {
		if(joy1Btn(6)) //If the driver is pressing button 6, scale down robot movements
			joystickFactor = JOYSTICKLOW;
		else
			joystickFactor = JOYSTICKHIGH;
		if(joy1Btn(5)) //If the driver is pressing button 5, lock to y-axis movement
			sideways = false;
		else
			sideways = true;
		if(joy1Btn(7)) //If the driver is pressing button 7, lock to x-axis movement
			forward = false;
		else
			forward = true;
	}
}
