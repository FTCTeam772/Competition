#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Hubs, S2, HTMotor, HTServo, none, none)
#pragma config(Sensor, S3, IR, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, LeftForward, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C1_2, FrontSideways, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_1, BackSideways, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C2_2, RightForward, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_1, Shoulder, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_2, Arm, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo, srvo_S2_C2_1, ArmServoLeft, tServoStandard)
#pragma config(Servo, srvo_S2_C2_2, ArmServoRight, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Flag for whether to use tank drive or not
//#define TANKDRIVE

//Constants
#define JOYSTICKHIGH 100
#define JOYSTICKLOW 30
#define ARMHIGH 100
#define ARMLOW 30
#define ARMTOP 2880
#define ARMBOTTOM 0
#define SERVOHIGH 10
#define SERVOLOW 2
#define BOTTOMPEG 0
#define MIDDLEPEG 1440
#define TOPPEG 2880
#define HANDMAX 255
#define HANDMIN 0

//Initialize our globals
byte joystickFactor = JOYSTICKHIGH; //Used to scale down robot movements
byte armFactor = ARMHIGH; //Used to scale arm movements
byte servoFactor = SERVOHIGH;
bool forward = true; //Used for direction locking
bool sideways = true;

task joystickControl() { //Asynchronous task for joystick control
	while(true) {
		//Joystick 1 - Driver
#ifdef TANKDRIVE
		if(forward) { //Part of direction locking mechanism
			//Big fancy statement to set the left forward motors equal to the converted joystick's left y axis unless it is in the natural variant range.
			motor[LeftForward] = joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 / 128.0 * joystickFactor : 0;
			//Same for right and for sideways (but use the second y axis for right side and use the x axes for sideways motors)
			motor[RightForward] = joystick.joy1_y2 > 10 || joystick.joy1_y2 < -10 ? joystick.joy1_y2 / 128.0 * joystickFactor : 0;
		}
		if(sideways) {
			motor[BackSideways] = joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 / 128.0 * joystickFactor : 0;
			motor[FrontSideways] = joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 / 128.0 * joystickFactor : 0;
		}
#else
		if(forward) { //Part of direction locking mechanism
			//Big fancy statement to set the left forward motors equal to the converted joystick's left y axis unless it is in the natural variant range and adds/subtracts to turn based on the joystick's right x axis.
			motor[LeftForward] = (joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 : 0 + (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
			motor[RightForward] = (joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 : 0 - (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
		}
  	if(sideways) {
  		//Same for sideways wheels but using the joystick's left x axis for sideways but still the joystick's right x axis for turning.
			motor[BackSideways] = (joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 : 0 - (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
			motor[FrontSideways] = (joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 : 0 + (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
		}
#endif
		//Joystick 2 - Operator
		if(joy2Btn(5) && ServoValue[ArmServoLeft] < HANDMAX && ServoValue[ArmServoRight] > HANDMIN) { //If button 5 is pressed and servos aren't at maximum, open hand
			servo[ArmServoLeft] += servoFactor; //Increase servo positions
			servo[ArmServoRight] -= servoFactor;
		}
		if(joy2Btn(6) && ServoValue[ArmServoLeft] > HANDMIN && ServoValue[ArmServoRight] < HANDMAX) { //If button 6 is pressed and servos aren't at minimum, close hand
			servo[ArmServoLeft] -= servoFactor; //Decrease servo positions
			servo[ArmServoRight] += servoFactor;
		}
		switch(joystick.joy2_TopHat) { //Check the tophat
			case 7: //If tophat is one of the top three states, move arm up
			case 0:
			case 1:
				if(nMotorEncoder[Arm] < ARMTOP) //Protects from operator forcing arm above its highest point
					motor[Arm] = armFactor;
				else
					motor[Arm] = 0;
				break;
			case 3: //If tophat is one of the bottom three states, move arm down
			case 4:
			case 5:
				if(nMotorEncoder[Arm] > ARMBOTTOM) //Protects from operator forcing the arm below its lowest point
					motor[Arm] = -armFactor;
				break;
			default: //Else stop it
				motor[Arm] = 0;
		}
	}
}

task main() {
	//Initialize
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = motor[Arm] = motor[Shoulder] = 0; //Turn off the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = nMotorEncoder[Arm] = nMotorEncoder[Shoulder] = 0; //Might as well reset the encoders too
	servo[ArmServoLeft] = 0; //And set the servos
	servo[ArmServoRight] = 255;
	waitForStart();
	StartTask(joystickControl); //Go ahead and start joysticks in their own task
	while(true) {
		//Joystick 1 - Driver
		if(joy1Btn(6)) //If the driver is pressing button 6, scale down robot movements
			joystickFactor = JOYSTICKLOW;
		else //Else leave at full speed
			joystickFactor = JOYSTICKHIGH;
		if(joy1Btn(5)) //If the driver is pressing button 5, lock to y-axis movement
			sideways = false;
		else
			sideways = true;
		if(joy1Btn(7)) //If the driver is pressing button 7, lock to x-axis movement
			forward = false;
		else
			forward = true;
		//Joystick 2 - Operator
		if(joy2Btn(1)) { //If the operator is pressing button 1, set arm to lowest peg
			nMotorEncoderTarget[Arm] = BOTTOMPEG; //Set the motor target
			motor[Arm] = nMotorEncoder[Arm] < BOTTOMPEG ? 100 : -100; //Start them in the direction of the target
			while(nMotorRunState[Arm] != runStateIdle); //Wait until they get there
			motor[Arm] = 0; //Then stop them
		}
		if(joy2Btn(2)) { //If the operator is pressing button 2, set arm to middle peg
			nMotorEncoderTarget[Arm] = MIDDLEPEG;
			motor[Arm] = nMotorEncoder[Arm] < MIDDLEPEG ? 100 : -100;
			while(nMotorRunState[Arm] != runStateIdle);
			motor[Arm] = 0;
		}
		if(joy2Btn(3)) { //If the operator is pressing button 3, set arm to top peg
			nMotorEncoderTarget[Arm] = TOPPEG;
			motor[Arm] = nMotorEncoder[Arm] < TOPPEG ? 100 : -100;
			while(nMotorRunState[Arm] != runStateIdle);
			motor[Arm] = 0;
		}
		if(joy2Btn(4)) { //If the operator is pressing button 4, set arm to home position
			nMotorEncoderTarget[Shoulder] = 0; //Set shoulder to home
			motor[Shoulder] = -100;
			while(nMotorRunState[Shoulder] != runStateIdle);
			motor[Shoulder] = 0;
			nMotorEncoderTarget[Arm] = 0; //Then set arm to home
			motor[Arm] = -100;
			while(nMotorRunState[Arm] != runStateIdle);
			motor[Arm] = 0;
		}
		if(joy2Btn(7)) //If the operator is pressing button 7, scale down hand movements
			servoFactor = SERVOLOW;
		else
			servoFactor = SERVOHIGH;
		if(joy2Btn(8)) //If the operator is pressing button 8, scale down arm movements
			armFactor = ARMLOW;
		else
			armFactor = ARMHIGH;
	}
}
