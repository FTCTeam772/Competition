#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Hubs, S2, HTMotor, HTServo, none, none)
#pragma config(Sensor, S3, IR, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, LeftForward, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C1_2, FrontSideways, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_1, BackSideways, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C2_2, RightForward, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_1, ArmLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_2, ArmRight, tmotorTetrix, PIDControl, encoder)
#pragma config(Servo, srvo_S2_C2_1, ArmServoLeft, tServoStandard)
#pragma config(Servo, srvo_S2_C2_2, ArmServoRight, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Flag for whether to use tank drive or not
//#define TANKDRIVE

//Constants
#define JOYSTICKHIGH 100
#define JOYSTICKLOW 30
#define ARMHIGH 100
#define ARMLOW 30
#define ARMTOP 1440
#define ARMBOTTOM -1440
#define SERVOHIGH 10
#define SERVOLOW 2

//Initialize our globals
byte joystickFactor = JOYSTICKHIGH; //Used to scale down robot movements
byte armFactor = ARMHIGH; //Used to scale arm movements
byte servoFactor = SERVOHIGH;
bool forward = true; //Used for direction locking
bool sideways = true;

task joystickControl() { //Asynchronous task for joystick control
	while(true) {
		//Joystick 1 - Driver
#ifdef TANKDRIVE
		if(forward) { //Part of direction locking mechanism
			//Big fancy statement to set the left forward motors equal to the converted joystick's left y axis unless it is in the natural variant range.
			motor[LeftForward] = joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 / 128.0 * joystickFactor : 0;
			//Same for right and for sideways (but use the second y axis for right side and use the x axes for sideways motors)
			motor[RightForward] = joystick.joy1_y2 > 10 || joystick.joy1_y2 < -10 ? joystick.joy1_y2 / 128.0 * joystickFactor : 0;
		}
		if(sideways) {
			motor[BackSideways] = joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 / 128.0 * joystickFactor : 0;
			motor[FrontSideways] = joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 / 128.0 * joystickFactor : 0;
		}
#else
		if(forward) { //Part of direction locking mechanism
			//Big fancy statement to set the left forward motors equal to the converted joystick's left y axis unless it is in the natural variant range and adds/subtracts to turn based on the joystick's right x axis.
			motor[LeftForward] = (joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 : 0 + (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
			motor[RightForward] = (joystick.joy1_y1 > 10 || joystick.joy1_y1 < -10 ? joystick.joy1_y1 : 0 - (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
		}
  	if(sideways) {
  		//Same for sideways wheels but using the joystick's left x axis for sideways but still the joystick's right x axis for turning.
			motor[BackSideways] = (joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 : 0 - (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
			motor[FrontSideways] = (joystick.joy1_x1 > 10 || joystick.joy1_x1 < -10 ? joystick.joy1_x1 : 0 + (int)(joystick.joy1_x2 > 10 || joystick.joy1_x2 < -10 ? joystick.joy1_x2 : 0)) / (128.0 + joystick.joy1_x2) * joystickFactor;
		}
#endif
		//Joystick 2 - Operator
		if(joy2Btn(5) && servoValue[ArmServoLeft] < 255 && servoValue[ArmServoRight] < 255) { //If button 5 is pressed and servos aren't at maximum, open hand
			servo[ArmServoLeft] += servoFactor; //Increase servo positions
			servo[ArmServoRight] += servoFactor;
		}
		if(joy2Btn(6) && servoValue[ArmServoLeft] > 0 && servoValue[ArmServoRight] > 0) { //If button 6 is pressed and servos aren't at minimum, close hand
			servo[ArmServoLeft] -= servoFactor; //Decrease servo positions
			servo[ArmServoRight] -= servoFactor;
		}
		switch(joystick.joy2_TopHat) { //Check the tophat
			case 7: //If tophat is one of the top three states, move arm up
			case 0:
			case 1:
				if(nMotorEncoder[ArmLeft] < ARMTOP) //Protects from operator forcing arm above its highest point
					motor[ArmLeft] = motor[ArmRight] = armFactor;
				else
					motor[ArmLeft] = motor[ArmRight] = 0;
				break;
			case 3: //If tophat is one of the bottom three states, move arm down
			case 4:
			case 5:
				if(nMotorEncoder[ArmRight] > -ARMTOP) //Protects from operator forcing the arm below its lowest point
					motor[ArmLeft] = motor[ArmRight] = -armFactor;
				break;
			default: //Else stop it
				motor[ArmLeft] = motor[ArmRight] = 0;
		}
	}
}

task main() {
	//Initialize
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = motor[ArmLeft] = motor[ArmRight] = 0; //Turn off the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = nMotorEncoder[ArmLeft] = nMotorEncoder[ArmRight] = 0; //Might as well reset the encoders too
	servo[ArmServoLeft] = servo[ArmServoRight] = 0; //And set the servos
	waitForStart();
	StartTask(joystickControl); //Go ahead and start joysticks in their own task
	while(true) {
		//Joystick 1 - Driver
		if(joy1Btn(6)) //If the driver is pressing button 6, scale down robot movements
			joystickFactor = JOYSTICKLOW;
		else
			joystickFactor = JOYSTICKHIGH;
		if(joy1Btn(5)) //If the driver is pressing button 5, lock to y-axis movement
			sideways = false;
		else
			sideways = true;
		if(joy1Btn(7)) //If the driver is pressing button 7, lock to x-axis movement
			forward = false;
		else
			forward = true;
		//Joystick 2 - Operator
		if(joy2Btn(7))
			servoFactor = SERVOLOW;
		else
			servoFactor = SERVOHIGH;
		if(joy2Btn(8))
			armFactor = ARMLOW;
		else
			armFactor = ARMHIGH;
	}
}
