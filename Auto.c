#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     FrontRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackRight,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackLeft,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     LeftSlide,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightSlide,    tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    zipties,              tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#include "constants.h"

//Useful functions
#include "common.h"

//Music player
#include "Player.h"

string programs[] = { "Left IR", "Left Non-IR", "Right IR", "Right Non-IR" };

void execute(bool ramp, bool def, bool kick, bool center, int roll) {			//I feel like this should be outside of task main()

	int irvalue = SensorValue[IR];	//May need to detect this at a different point
	double xPos = 0;
	double yPos = 0;
	double angle = 0;

	//***NOTE*** All IR values in various branches have not been calibrated. They might be (for example) 3, 4, or 5 instead of 4, 5, or 6.
		if (ramp == true) {			//If starting from ramp
			move(0, 100, 200, 800);

		if (def == true) {
				//run defense program for ramp beginning

			}
			else {

				if (kick == true) {
					//run kickstand method for ramp start


					if (irvalue == 4) {
						//knock over kickstand and return to a common point
					}

					if (irvalue == 5) {
						//knock over kickstand and return to a common point
					}

					if (irvalue == 6) {
						//knock over kickstand and return to a common point
				  }
				}

				if (center == true) {						//If scoring in center goal
					//locate center goal and score in it
					if (irvalue == 4) {

					}
					if (irvalue == 5) {

					}
					if (irvalue == 6) {

					}
					//reset robot to home position
				}
				if (center == false) {		//If not scoring in center goal

					if (roll == 0) {
					//do nothing
					}

					if (roll == 1) {
					//score in medium goal and bring it back (bring it back can be a common.h method) to parking zone
						turn(20, SensorValue[Compass]);
						move(angle, xPos, yPos, 700);
						//raiseSlides
						//releaseBalls
						//lowerSlides
						turn (140, SensorValue[Compass]);
						move(angle, xPos, yPos, 1000);

					}
					if (roll == 2) {
					//score in tallest goal and bring it back
						turn(30, SensorValue[Compass]);
						move(angle, xPos, yPos, 200);
						turn(-90, SensorValue[Compass]);
						move(angle, xPos, yPos, 500);
						//raiseSlides
						//releaseBalls
						//lowerSlides
						turn(210, SensorValue[Compass]);
						move(angle, xPos, yPos, 1200);

					}
					if (roll == 3) {
					//score in medium and tallest then bring back the tallest goal


					}
				}
			}

		}

		if (ramp == false) {

			if (def == true) {
				//run defense program for floor beginning
			}
			if (kick == true) {
					//run kickstand method for ramp start (try to combine with ramp == true branch by finding a common start point? idk)

					if (irvalue == 1) {

					}

					if (irvalue == 2) {

					}

					if (irvalue == 3) {

				  }
				}

				if (center == true) {
					//locate center goal and score in it

					if (irvalue == 1) {

					}
					if (irvalue == 2) {

					}
					if (irvalue == 3) {

					}
					//reset robot to home position
				}
				if (center == false) {		//If not scoring in center goal

					if (roll == 0) {
					//do nothing

					}
					if (roll == 1) {
					//score in medium goal and bring it back (bring it back can be a common.h method) to parking zone

					}
					if (roll == 2) {
					//score in tallest goal and bring it back

					}
					if (roll == 3) {
					//score in medium and tallest then bring back the tallest goal

					}
				}
			}
	}

task main() {
	bDisplayDiagnostics = false; //Disable screen diagnostics until Autonomous is set up

	//Initialize
	initialize();

	int prog = 0; //Autonomous program

	//Prompt for autonomous program
	nxtDisplayCenteredTextLine(3, "Select program:");
	nxtDisplayCenteredTextLine(5, "%s", programs[prog]);
	while(nNxtButtonPressed != 3) { //Wait for press
		wait10Msec(20);

		if(nNxtButtonPressed == 2 && prog > 0) { //Decrement the program
			prog--;
			nxtDisplayCenteredTextLine(5, "%s", programs[prog]); //Display its name
		}
		else if(nNxtButtonPressed == 1 && prog < sizeof(programs)/sizeof(programs[0]) - 1) { //Increment the program
			prog++;
			nxtDisplayCenteredTextLine(5, "%s", programs[prog]);
		}
	}
	while(nNxtButtonPressed == 3){ //Wait for unpress

		//Add a delay
	int delay = 0;
	nxtDisplayCenteredTextLine(3, "Delay:");
	nxtDisplayCenteredTextLine(5, "%d", delay);
	while(nNxtButtonPressed != 3) { //Wait for press
		wait10Msec(20);

		if(nNxtButtonPressed == 2 && delay > 0) { //Decrement the delay
			delay -= 2;
			nxtDisplayCenteredTextLine(5, "%d", delay);
		}
		else if(nNxtButtonPressed == 1 && delay < 30) { //Increment the delay
			delay += 2;
			nxtDisplayCenteredTextLine(5, "%d", delay);
		}
	}
	while(nNxtButtonPressed == 3); //Wait for unpress

	bDisplayDiagnostics = true; //Enable screen diagnostics for match

	//Go time!
	waitForStart();

	//Play the Imperial March
	setSong("ImperialMarch.nms");
	play();

	wait10Msec(delay * 100);

	}

	//SensorValue[IR]

	execute(RAMP, DEF, KICK, CENTER, ROLLING);

	//writeDebugStream("IR:\t%d\n", SensorValue[IR]);

}
