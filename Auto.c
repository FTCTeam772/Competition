#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          RightHand,     tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          LeftHand,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          Flag,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     FrontLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FrontRight,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BackLeft,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackRight,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     LeftArmShoulder, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     LeftArmElbow,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     RightArmShoulder, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     RightArmElbow, tmotorTetrix, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#include "constants.h"

//Useful functions
#include "common.h"

//Music player
#include "Player.h"

task main() {
	//Initialize
	initialize();

	//Go time!
	waitForStart();

	//Play the Imperial March
	setSong("ImperialMarch.nms");
	play();

#if AUTO_PROGRAM == 0 || AUTO_PROGRAM == 2
	//Go forward until the IR beacon is found
	nMotorEncoder[FrontLeft] = nMotorEncoder[FrontRight] = nMotorEncoder[BackLeft] = nMotorEncoder[BackRight] = 0;
#if AUTO_PROGRAM == 0
	motor[FrontLeft] = -DRIVE_HIGH;
	motor[BackRight] = DRIVE_HIGH;
#else
	motor[FrontLeft] = DRIVE_HIGH;
	motor[BackRight] = -DRIVE_HIGH;
#endif
	while(SensorValue[IR] != 6 && (abs(nMotorEncoder[FrontLeft]) < AUTO_DETECT || abs(nMotorEncoder[BackRight]) < AUTO_DETECT)); //Wait until we either hit the IR or the last basket
	motor[FrontLeft] = motor[BackRight] = 0;
	//Drop a block and move back
	int offset = nMotorEncoder[FrontLeft]; //Save current distance traveled
	wait();
	//Correct for IR detection
	move(0, AUTO_IR_CORRECT);
	wait();
	turn(AUTO_IR_TURN);
	wait();
	//Drop
	moveRightArm(ARM_SHOULDER_BASKET, 0); //Move shoulder first to prevent problems
	moveRightArm(ARM_SHOULDER_BASKET, ARM_ELBOW_BASKET);
	wait();
	openRightHand();
	wait();
	closeRightHand();
	wait();
	moveRightArm(0, 0);
	wait();
	//Undo actions to continue on
	turn(-AUTO_IR_TURN);
	wait();
	offset -= AUTO_IR_CORRECT; //Correct offset for amount moved for IR correction
	//Continue to end of line
	nMotorEncoder[FrontLeft] = nMotorEncoder[FrontRight] = nMotorEncoder[BackLeft] = nMotorEncoder[BackRight] = 0;
#if AUTO_PROGRAM == 0
	motor[FrontLeft] = -DRIVE_HIGH;
	motor[BackRight] = DRIVE_HIGH;
#else
	motor[FrontLeft] = DRIVE_HIGH;
	motor[BackRight] = -DRIVE_HIGH;
#endif
	while(abs(nMotorEncoder[FrontLeft]) + abs(offset) < AUTO_DETECT || abs(nMotorEncoder[BackRight]) + abs(offset) < AUTO_DETECT); //Continue but adjust for offset
	motor[FrontLeft] = motor[BackRight] = 0;
	wait();

	//Go to ramp
#if AUTO_PROGRAM == 0
	move(0, AUTO_RAMP_1); //Go a little bit further
#else
	move(0, -AUTO_RAMP_1);
#endif
	wait();
	move(AUTO_RAMP_2, 0); //Move in front of the ramp
	wait();
	turn(AUTO_RAMP_TURN); //Turn so that two wheels hit the front of the ramp
	wait();
#if AUTO_PROGRAM == 0
	move(AUTO_RAMP_UP, -AUTO_RAMP_UP); //Go up the ramp
#else
	move(-AUTO_RAMP_UP, AUTO_RAMP_UP);
#endif
	wait();
#elif AUTO_PROGRAM == 1 || AUTO_PROGRAM == 3
	//Place a block in first basket
#if AUTO_PROGRAM == 1
	move(AUTO_FIRST_BASKET, -AUTO_FIRST_BASKET); //Move up to first basket
#else
	move(-AUTO_FIRST_BASKET, AUTO_FIRST_BASKET);
#endif
	wait();
	//Drop
	moveRightArm(ARM_SHOULDER_BASKET, 0); //Move shoulder first to prevent problems
	moveRightArm(ARM_SHOULDER_BASKET, ARM_ELBOW_BASKET);
	wait();
	openRightHand();
	wait();
	closeRightHand();
	wait();
	moveRightArm(0, 0);
	wait();

	//Go to ramp and drive through to the opposite side
#if AUTO_PROGRAM == 1
	move(AUTO_RAMP, -AUTO_RAMP); //Move in front of ramp
#else
	move(-AUTO_RAMP, AUTO_RAMP);
#endif
	wait();
	move(AUTO_RAMP_OVER, AUTO_RAMP_OVER); //Go onto and to the other side of the ramp
	wait();
#endif
}
