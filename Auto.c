#pragma config(Hubs, S1, HTMotor, HTMotor, none, none)
#pragma config(Hubs, S2, HTMotor, HTServo, none, none)
#pragma config(Sensor, S3, IR, sensorHiTechnicIRSeeker1200)
#pragma config(Motor, mtr_S1_C1_1, LeftForward, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C1_2, FrontSideways, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor, mtr_S1_C2_1, BackSideways, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S1_C2_2, RightForward, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_1, ArmLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor, mtr_S2_C1_2, ArmRight, tmotorTetrix, PIDControl, encoder)
#pragma config(Servo, srvo_S2_C2_1, ArmServoLeft, tServoStandard)
#pragma config(Servo, srvo_S2_C2_2, ArmServoRight, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#define FORWARD 6000 //Number of encoder revolutions to go forward
#define TURN 600 //Same as above but for turn
#define CENTERFORWARD 1800 //For going forward to the center
#define SIDEWAYS 1800 //Number of encoder revolutions to go sideways (for left or right)

void turn() {
	//Reset encoders, set motors opposite their counterparts and in a turning motion (left - backward, front - left, right - forward, back - right), wait on encoders, then stop the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = 0;
	motor[LeftForward] = motor[FrontSideways] = -100; //Set motors in opposite directions
	motor[RightForward] = motor[BackSideways] = 100;
	while(nMotorEncoder[LeftForward] > -TURN && nMotorEncoder[FrontSideways] > -TURN && nMotorEncoder[RightForward] < TURN && nMotorEncoder[BackSideways] < TURN); //Wait until right encoder counts up to TURN and left counts down to -TURN
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = 0; //Stop
}

void forward() {
	//Reset encoders, set motors to forward, wait on encoders, then stop the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = 0;
	motor[LeftForward] = motor[RightForward] = 100;
	while(nMotorEncoder[LeftForward] < CENTERFORWARD && nMotorEncoder[RightForward] < CENTERFORWARD);
	motor[LeftForward] = motor[RightForward] = 0;
}

void right() {
	//Do something similar as going forward but using sideways motors
	nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = 0;
	motor[BackSideways] = motor[FrontSideways] = 100;
	while(nMotorEncoder[BackSideways] < SIDEWAYS && nMotorEncoder[FrontSideways] < SIDEWAYS);
	motor[BackSideways] = motor[FrontSideways] = 0;
}

void left() {
	nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = 0; //Since the encoder will be counting backwards, set the encoder to 0 ...
	motor[BackSideways] = motor[FrontSideways] = -100;
	while(nMotorEncoder[BackSideways] > -SIDEWAYS && nMotorEncoder[FrontSideways] > -SIDEWAYS);//... and wait until it is -SIDEWAYS
	motor[BackSideways] = motor[FrontSideways] = 0;
}

void placeRing() {
	//To be done when the arm is finished and decided
}

task main() {
	//Initialize
	motor[LeftForward] = motor[RightForward] = motor[BackSideways] = motor[FrontSideways] = 0; //Turn off the motors
	nMotorEncoder[LeftForward] = nMotorEncoder[RightForward] = nMotorEncoder[BackSideways] = nMotorEncoder[FrontSideways] = 0; //Might as well reset the encoders too
	waitForStart();
	//Autonomous
	/* Here is the autonomous idea:
	*			Read the IR sensor to get a general area of the Beacon.  Use that to figure out the proper column (shouldn't be too hard)
	*			Then decide which autonomous set of commands to run.  Proper a bunch of if...else if... else if... else statements.  And
	*			If we can't find the IR Beacon (which we should make code for that just in case) then we will just put the ring on the
	*			center peg (or some other predefined spot if necessary).  The movements will be hardcoded so we can tune to the best accuracy.
	*/
	//Go forward for FORWARD revolutions up to the columns
	nMotorEncoder[RightForward] = nMotorEncoder[LeftForward] = 0; //Reset the encoders
	motor[RightForward] = motor[LeftForward] = 100; //Turn the motors on
	while(nMotorEncoder[RightForward] < FORWARD && nMotorEncoder[LeftForward] < FORWARD); //Wait until the encoders hit FORWARD
	motor[RightForward] = motor[LeftForward] = 0; //Stop the motors
	wait10Msec(300); //Wait on motors to stop
	//Turn
	turn();
	wait10Msec(300);
	//Forward to center
	forward();
	wait10Msec(300);
	switch(SensorValue[IR]) { //0 if not found, else 1-9, 4 is a narrow area and will be positioned to be center
		case 1: //For values 1-3, assume the beacon is on the left column
		case 2:
		case 3:
			left();
			break;
		case 4: //For value 4 (center), assume the beacon is on the center column and just place the ring
			break;
		case 5: //For values 5-7, assume the beacon is on the right column
		case 6:
		case 7:
			right();
			break;
		default: //For value 0 (or other uncaught numbers), just put it on the center peg and hope for the best
	}
	placeRing(); //Go ahead and place the ring now that we are positioned
}
