#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IR_left,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     IR_right,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     FrontRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     BackRight,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     FrontLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     BackLeft,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     LeftSlide,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     RightSlide,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    zipties,              tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

//Constants
#include "constants.h"

//Useful functions
#include "common.h"

//Music player
#include "Player.h"

string programs[] = { "Left IR", "Left Non-IR", "Right IR", "Right Non-IR" };

long centergoal = CENTER_GOAL + HIGH_GOAL;

void execute(bool ramp, bool def, bool kick, bool center, int roll) {			//I feel like this should be outside of task main()



int irvalue;

		if (ramp == true) {			//If starting from ramp

			if (def == true) {
				//run defense program for ramp beginning

			}
			else {

				if (kick == true) {/*
					//run kickstand method for ramp start

					if (SensorValue[IR_left] == 4 && SensorValue[IR_right] == 0) { //center goal is facing the box
						//knock over kickstand and return to a common point
						turn(45);
						drive(4000);
						turn(135);
						drive(3000);
						//moveTo(angle, xPos, yPos, 0, 800);
					}

					if (SensorValue[IR_left] == 4 && SensorValue[IR_right] == 5) { //center goal is facing at a 45 degree angle between the box and side of the ramp
						//knock over kickstand and return to a common point
						turn(45);
						drive(4000);
						turn(135);
						drive(3000);
						//moveTo(angle, xPos, yPos, 0, 800);
					}

					if (SensorValue[IR_left] == 5 && SensorValue[IR_right] == 5) { //center goal is facing toward the side of the ramp
						turn(45);
						drive(4000);
						turn(135);
						drive(3000);
						//moveTo(angle, xPos, yPos, 0, 800);
				  }*/
				}

				//HAS NOT BEEN CALIBRATED
				if (center == true) {//If scoring in center goal
					drive(9000);
				//locate center goal and score in it
					if (SensorValue[IR_left] == 7 && SensorValue[IR_right] == 0) { //center goal is facing toward the box
						turn(45);
						drive(10000);
						turn(-45);
						liftScore(centergoal);

					}
					if (SensorValue[IR_left] == 6 && SensorValue[IR_right] == 5) { //center goal is facing at a 45 degree angle between the box and side of the ramp
						//knock over kickstand and return to a common point
						turn(45);
						drive(10000);
						turn(30);
						liftScore(centergoal);
					}
					if (SensorValue[IR_left] == 5 && SensorValue[IR_right] == 5) { //center goal is facing toward the side of the ramp
						turn(45);
						drive(10000);
						turn(80);
						liftScore(centergoal);
					}
					//reset robot to home position
				}
				if (center == false) {		//If not scoring in center goal

					//(0 = no rolling goals, 1 = medium goal only, 2 = high goal only, 3 = both goals)
					if (roll == 0) {
					//do nothing
					}

					if (roll == 1) {
					//score in medium goal and bring it back (bring it back can be a common.h method) to parking zone
						drive(12000);
						liftScore(MEDIUM_GOAL);
						//turn(150);
						//drive(10000);
					}
					if (roll == 2) {
					//score in tallest goal and bring it back
						drive(9000);
						turn(-2500);
						drive(2250);
						turn(4250);
						drive(4000);
						liftScore(HIGH_GOAL);
						//turn(90);
						//drive(12000);
					}
					if (roll == 3) {
					//score in medium and tallest then bring back the tallest goal
						drive(12000);
						liftScore(MEDIUM_GOAL);
						drive(-1500);
						turn(-2500);
						drive(2000);
						turn(4250);
						drive(4000);
						liftScore(HIGH_GOAL);
						//turn(140);
						//drive(10000);
					}
				}
			}
		}

		if (ramp == false) {

			if (def == true) {
				//run defense program for floor beginning
			}
			if (def == false) {
				//needs to be calibrated
				if (center == true) {
					//locate center goal and score in it
					drive(-3000);

					if ((SensorValue[IR_left] == 0 && SensorValue[IR_right] == 0)	|| (SensorValue[IR_left] == 6 && SensorValue[IR_right] == 0) || (SensorValue[IR_left] == 7 && SensorValue[IR_right] == 0)) { //center goal is facing at 45 degree angle
						//score in center goal
						turn(3350);
						drive(12000);
						turn(3350);
						drive(3000);
						turn(3350);
						drive(500);
						liftScore(centergoal);
						irvalue = 0;
					}
					if ((SensorValue[IR_left] == 3 && SensorValue[IR_right] == 0) || (SensorValue[IR_left] == 4 && SensorValue[IR_right] == 0)) { //center goal is facing toward the side of the ramp
						//score in center goal
						turn(45);
						drive(10000);
						turn(30);
						liftScore(centergoal);
						irvalue = 1;
					}
					if ((SensorValue[IR_left] == 5 && SensorValue[IR_right] == 6) || (SensorValue[IR_left] == 5 && SensorValue[IR_right] == 7)) { //center goal is facing the box
						//score in center goal
						oneSideTurn(-3000, false);
						oneSideTurn(-3000, true);
						drive(300);
						liftScore(centergoal);
						irvalue = 2;
					}
					//reset robot to home position
				if (kick == true) {

					if (irvalue == 0) { //center goal is facing at 45 degree angle
						//knock over kickstand
						irvalue = 0;
						turn(2500);
						drive(4000);
						turn(-1580);
						drive(-5500);
						//moveTo(angle, xPos, yPos, 0, 800);
					}

					if (irvalue == 1) { //center goal is facing the box
						//knock over kickstand
						irvalue = 1;
						oneSideTurn(-1300, false);
						oneSideTurn(-1300, true);
						drive(-4000);

						//moveTo(angle, xPos, yPos, 0, 800);
					}

					if (irvalue == 2) { //center goal is facing toward the side of the ramp
						//knock over kickstand
						irvalue = 2;
						oneSideTurn(-2000, false);
						drive(-1400);
						turn(-4685);
						drive(-4000);

						//moveTo(angle, xPos, yPos, 0, 800);
				  }
				}
			}

				if (center == false) {		//If not scoring in center goal
					
					if (kick == true) {

					drive(-3000);
					//45 degree & ramp facing ones needs calibration
					if ((SensorValue[IR_left] == 0 && SensorValue[IR_right] == 0)	|| (SensorValue[IR_left] == 6 && SensorValue[IR_right] == 0) || (SensorValue[IR_left] == 7 && SensorValue[IR_right] == 0)) { //center goal is facing at 45 degree angle
						//knock over kickstand
						turn(2500);
						drive(4000);
						turn(-1580);
						drive(-5500);
						//moveTo(angle, xPos, yPos, 0, 800);
						if (roll == 1) {
						//score in medium goal and bring it back
						drive(2200);
						turn(-4100);
						drive(7000);
						liftScore(MEDIUM_GOAL);
						//turn(150);
						//drive(10000);
						}
						if (roll == 2) {
						//score in tallest goal and bring it back
						drive(2200);
						turn(-3800);
						drive(4500);
						oneSideTurn(4000, false);
						drive(4000);
						oneSideTurn(3000, true);
						liftScore(HIGH_GOAL);
						//turn(90);
						//drive(12000);
						}
					}
					if ((SensorValue[IR_left] == 5 && SensorValue[IR_right] == 6) || (SensorValue[IR_left] == 5 && SensorValue[IR_right] == 7)) { //center goal is facing toward the box
						//knock over kickstand
						oneSideTurn(-1500, false);
						oneSideTurn(-1400, true);
						drive(-4000);
						//moveTo(angle, xPos, yPos, 0, 800);
						if (roll == 1) {
						//score in medium goal and bring it back
						drive(2200);
						turn(-4100);
						drive(7000);
						liftScore(MEDIUM_GOAL);
						//turn(150);
						//drive(10000);
						}
						if (roll == 2) {
						//score in tallest goal and bring it back
						drive(2200);
						turn(-3800);
						drive(4500);
						oneSideTurn(4000, false);
						drive(4000);
						oneSideTurn(3000, true);
						liftScore(HIGH_GOAL);
						//turn(90);
						//drive(12000);
						}
					}
					if ((SensorValue[IR_left] == 3 && SensorValue[IR_right] == 0) || (SensorValue[IR_left] == 4 && SensorValue[IR_right] == 0)) { //center goal is facing the side of the ramp
						//knock over kickstand			
						oneSideTurn(-2000, false);
						drive(-1400);
						turn(-4685);
						drive(-4000);
						//moveTo(angle, xPos, yPos, 0, 800);
						if (roll == 1) {
						//score in medium goal and bring it back
						drive(2200);
						turn(-2000);
						drive(5000);
						liftScore(MEDIUM_GOAL);
						//turn(150);
						//drive(10000);
						}
						if (roll == 2) {
						//score in tallest goal and bring it back
						drive(3100);
						turn(-3400);
						drive(4500);
						turn(2000);
						drive(1000);
						liftScore(HIGH_GOAL);
						//turn(90);
						//drive(12000);
						}
				  }
				}
				}
			}
		}
}
task main() {
//	bDisplayDiagnostics = false; //Disable screen diagnostics until Autonomous is set up

	//Initialize
	initialize();

//	bDisplayDiagnostics = true; //Enable screen diagnostics for match

	//Go time!
	waitForStart();

	//Play the Imperial March
	//setSong("ImperialMarch.nms");
	//play();

//	wait10Msec(delay * 100);

  execute(RAMP, DEF, KICK, CENTER, ROLLING);

	//writeDebugStream("IR:\t%d\n", SensorValue[IR]);
  //writeDebugStream("LeftSlide:\t%d\n", nMotorEncoder[LeftSlide]);
  //writeDebugStream("RightSlide:\t%d\n", nMotorEncoder[RightSlide]);

}
